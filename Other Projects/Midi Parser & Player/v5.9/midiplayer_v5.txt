@name Midiplayer v5

# [ Config ] #
@persist Speed HoloCount OpsLimit Loop [Version LastUpdate]:string PowerSaving TimeMult

# [ General & Misc ] #
@persist [Mode PrevMode]:string HoloC [Status ]:table HoloY HoloX ChannelC

# [ Functions ] #
@persist Requesting Importing ProgLast Archiving ArLoaded ArLoading
 
# [ Player ] #
@persist IsPlaying IsParsed Downloaded StartTime Playtime NoteCounter ExpCheck PrevZ PitchBuff PrevSid
@persist [Midi Directory]:string 
@persist [Notes Data Counters Timetracker AltSounds]:table
@persist [ AvSpeakers Instruments  ]:array

@trigger all

if(first())
{  
    #[
        Garry's Mod Expression 2 Midi Player, made by Sixmax.
        
        
        To hear everything make sure to download the "Playable Piano"-Addon from the Workshop.
        
        Also a good thing to do is exceed the sound limitations from E2.
        
        What I use:
           wire_expression2_maxsounds 150
           wire_expression2_sound_burst_max 150
           wire_expression2_sound_burst_rate 0
        
        Those Convars have to be changed in the Server console or set as startup in the autocexec file.
    ]#
    
    
    Version       = "5.95"
    LastUpdate    = "Sound Enhancement Update"
    Speed         = 120
    Loop          = 0
    HoloCount     = 150
    OpsLimit      = 6000
    PowerSaving   = 0
    TimeMult      = 1
    
    runOnChat(1)
    runOnFile(1)
    #ifdef runOnHTTP(number)
    runOnHTTP(1)
    #endif
    runOnTick(1)  
    runOnLast(1)

    OpsLimit = (100 / softQuota()) * OpsLimit

    entity():setMass(250)
  #  entity():setColor(vec(140,20,140))
  #  entity():setMaterial("debug/debugdecalwireframe")
    
    #include "libraries/midi_library_v3"
    
    Status["status", string]   = "Idle"
    Status["tracks", table]    = table()
    Status["filename", string] = ""
    Status["songname", string] = ""
    Status["author", string]   = ""
    Status["progress", number] = 0
    
    # [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] #
    # [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] #
    # [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] #


    function number string:isUrl()
    {
        return min(This:findRE("(http)s?(://)"),1)
    }
    
    function number request(Url:string)
    {
        #ifdef runOnHTTP(number)
        if(!Requesting & httpCanRequest())
        {
            httpRequest(Url)   
            Requesting = 1
        }
        else
        {
            if(httpClk())
            {
                if(httpSuccess())
                {
                    Requesting = 0
                    return 1    
                } 
                else
                {
                    Requesting = 0
                    return 2   
                }
            }   
        }
        #endif
    
        return 0
    }

    function number import(Path:string)
    {
        if(!Importing & fileCanLoad())
        {
            fileLoad(Path)
            Importing = 1   
        }
        else
        {
            if(fileClk() & !fileLoading())
            {
                if(fileStatus() == _FILE_OK)
                {
                    Importing = 0    
                    return 1   
                }   
                else
                {           
                    Importing = 0    
                    return 2  
                }
            }   
        }  
        
        return 0
    }

    function string formatTime(Time)
    {
        local Minutes = floor(Time / 60)
        local Seconds = floor(Time % 60)
        
        return Minutes + "m " + Seconds + "s"
    }

    function void updateStatus()
    {
        if(realtime() > ProgLast)
        {
            local Name = "Sixmax' Midi Player - v" + Version + "\n> " + LastUpdate + " <\n[] [] [] [] [] [] [] [] [] [] [] [] [] [] [] []"
            
            if(Status["filename", string] != "")
            {
                local Fm = Status["filename", string]
                
                if(Fm:isUrl())
                {
                    Fm = Fm:replaceRE("(http)s?(://www.)", "")   
                }
                else
                {
                    Fm = Fm + ".txt"    
                }
                
                Name = Name + "\nFilename: " + Fm
            }
       
            if(Midi != "")
            {
                Name = Name + "\nSize: " + ceil(Midi:length() / 1024, 2) + "kb"   
            }    

            if(Status["tracks", table]:count() > 0)
            {
                Name = Name + "\n\nTrack Count: " + Status["tracks", table]:count()   

                #[                        
                    for(I = 1, Status["tracks", table]:count())
                    {
                        if(I > 3)
                        {
                            Name = Name + "\n..."
                            break   
                        }
                    
                        local Track = Status["tracks", table][I, table]
                        local TrackName = Track["trackname", string]
                        
                        Name = Name + "\n" + I + ". " + (TrackName != "" ? TrackName : "Unnamed Track")
                    }
                ]#
            }
          
            if(Status["speakers", number] > 0)
            {
                Name = Name + "\nSpeakers in use: " + Status["speakers", number] + "/" + HoloCount
            }
            
            if(Status["status", string] != "")
            {
                Name = Name + "\n\nStatus: " + Status["status", string]   
            }
            
            if(!IsPlaying)
            {
                if(Status["progress", number] > 0)
                {
                    Name = Name + "\nProgress: " + Status["progress", number] + "%"
                }
            }
            else
            {
                Name = Name + "\n" + formatTime(Status["progress", number]) + " / " + formatTime(Playtime)
            }
            
            if(Loop)
            {
                Name = Name + "\nLooping: true"   
            }
            
            setName(Name)
            
            ProgLast = realtime() + 0.5
        }
    }

    function string encodeFilename(Input:string)
    {
        local Result = Input
        foreach(I, Reserved:string = array("<", ">", ":", "\"", "/", "\\", "|", "?", "*", " "))
        {
            Result = Result:replace(Reserved, "_")   
        }  
        return Result
    }

    function number said(Command:string)
    {
        local Result = owner():lastSaid():explode(" ")[1, string] == Command & chatClk(owner())
        if(Result)
        {
            hideChat(1)   
            return 1
        }
        return 0
    }
    
    function string told(Command:string)
    {
        local Last = owner():lastSaid()
        if(Last)
        {     
            if(Last:explode(" ")[1, string] == Command & chatClk(owner()))
            {
                hideChat(1)
                return Last:sub(Command:length() + 2, Last:length())   
            }
        }
        return ""
    }

    function void setMode(NewMode:string)
    {
        PrevMode = Mode
        Mode     = NewMode
    } 

    function void pOut(Color:vector, Code:string, Message:string, Sound:string)
    {
        printColor(vec(0), ">> [", Color, Code, vec(0), "] ", vec(255), Message)     
        entity():soundPlay(hash(Code + Message), 2, Sound)      
    }

    function void errOut(Code:string)
    {
        pOut(vec(255,0,0), "Error", Code, "buttons/button8.wav") 
    }

    function void sucOut(Code:string)
    {
        pOut(vec(0,255,0), "Success", Code, "buttons/button9.wav")         
    }

    function void warOut(Code:string)
    {
        pOut(vec(255,255,0), "Warning", Code, "buttons/button4.wav")    
    }

    function void zChannel(I, Note, F)
    {
        if(!PowerSaving)
        {
            local Extra = ((5 / 128) * Note) #* Vol
    
            if(abs(Extra - PrevZ) > 0.1 | F)
            {
                local Index = HoloC + I
                local CurPos = entity():toLocal(holoEntity(Index):pos()):setZ(0)
                holoPos(Index, entity():toWorld(CurPos + vec(0,0,1.5 + Extra)))            
                PrevZ = Extra
            }
        } 
    }

    function void resetSounds()
    {
        AvSpeakers:clear()
        
        for(I = 1, HoloCount)
        {
            soundStop(Notes[I, table]["sid", number])       
            AvSpeakers:pushNumber(I)
        }

        for(I = 1, 16)
        {
            zChannel(I, 0, 1)
        }   
        
        Notes:clear()
    }

    function void halt()
    {
        PitchBuff     = 0
        Playtime      = 0
        IsPlaying     = 0
        Importing     = 0
        Requesting    = 0
        IsDownloading = 0
        Downloaded    = 0
        IsParsed      = 0
        NoteCounter   = 1
        LastChannel   = -1
        PrevZ         = 0
        Midi          = ""
        PrevZ         = 0
        Data          = table()
        Counters      = table()
        Directory     = "" 
              
        midiLibReset()
    
        resetSounds()

        Status["status", string]   = "Idle"
        Status["tracks", table]    = table()
        Status["filename", string] = ""
        Status["songname", string] = ""
        Status["author", string]   = ""
        Status["progress", number] = 0
        Status["speakers", number] = 0
    }

    function void playback(Dir:string)
    {
        halt()
        Directory = Dir:replaceRE("%s", "")
        setMode("loadMidi")        
    }

    # [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] #
    # [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] #
    # [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] #

    function void collectGarbage()
    {
        local InUse = 0
        for(I = 1, Notes:count())
        {
            local Note          = Notes[I,            table]
            local SpeakerNumber = Note["speaker",    number]
            local SoundID       = Note["sid",        number]
            local Expiration    = Note["expiration", number] + 0.1
            
            if(realtime() > Expiration)
            {
                if(Notes[I, table]:count())
                {
                    if(!PowerSaving)
                    {
                        zChannel(Note["channel", number], 0, 0)
                    }
                    soundStop(SoundID)
                    Notes:remove(I)
                    AvSpeakers:pushNumber(SpeakerNumber) 
                } 
                else
                {
                    InUse++   
                }  
            }
        }
        
        if(changed(InUse > HoloCount - 10) & InUse > HoloCount - 10)
        {
            warOut("Speaker limit is being reached!")
        }     
                
        Status["speakers", number] = InUse  
    }    
    
    function void backgroundWorker()
    {                
        updateStatus()

        if(IsPlaying)
        {
            if(realtime() > ExpCheck)
            {                            
                collectGarbage()                 
                ExpCheck = realtime() + (1.5 + (1 * PowerSaving)) 
            }   
        }
    }
    
    function string bool(N)
    {
        return N ? "true" : "false"   
    }

    function void chatCommands()
    {
        local Play = told("/play")
        local Save = told("/save")
        local SSP  = told("/speed")
        local STS  = told("/time")
        
        if(Play)
        {
            playback(Play)
        }   
        elseif(Save)
        {
            local Filename = Save

            if(Filename:replaceRE("%s", ""))
            {               
                if(fileCanWrite())
                {
                    Filename = encodeFilename(Filename)
                   
                    fileWrite(">e2shared/MidiParser/" + Filename + ".txt", Midi)
                    
                    sucOut("Midi saved as: " + Filename + ".txt, in e2shared/midiparser/.")
                }
                else
                {
                    errOut("Please wait a moment, before saving another Midi.")
                }    
            }      
            else
            {
                errOut("Invalid Filename.")    
            }                 
        }   
        elseif(said("/stop"))
        {
            sucOut("All Events have been stopped")
            setMode("resetPlayer")
        }
        elseif(SSP)
        {
            Speed = SSP:toNumber()
            sucOut("Speed has been set to: " + Speed)  
        }
        elseif(said("/loop"))
        {
            Loop = !Loop
            sucOut("Looping has been toggled to: " + bool(Loop))   
        }
        elseif(STS)
        {
            TimeMult = STS:toNumber()
            sucOut("Time multiplier adjusted to: " + TimeMult)   
        }
    }

    function void loadMidi()
    {
        if(!Directory)
        {
            errOut("Invalid Path or Url.")
            setMode("resetPlayer")
            return      
        }
        
        Status["status", string] = "Loading Midi..."
        
        local IsUrl = Directory:isUrl()
        
        Status["filename", string] = Directory
        
        switch(Downloaded)
        { 
            case 0,
                if(IsUrl)
                {
                    Downloaded = request(Directory)            
                }
                else
                {
                    Downloaded = import(">e2shared/midiparser/" + Directory + ".txt")
                }            
            break  
            
            case 1,
                #ifdef httpData()
                Midi = IsUrl ? httpData() : fileRead()       
                #else
                Midi = fileRead()
                #endif
                        
                if(!min(Midi:findRE("^(MThd).*"), 1))
                {
                    errOut("Not a Midi file.")
                    setMode("resetPlayer")
                }             
                else
                {
                    sucOut("Midi loaded.")
                    setMode("runParser")
                }
            break
            
            case 2,
                if(IsUrl)
                {
                    errOut("Invalid Url.")   
                }
                else
                {
                    if(fileStatus() == _FILE_404)
                    {
                        errOut("Invalid File.")   
                    }
                    elseif(fileStatus() == _FILE_UNKNOWN)
                    {
                        errOut("File Unknown.")   
                    }
                    elseif(fileStatus() == _FILE_TIMEOUT)
                    {
                        errOut("File timed out.")   
                    }
                }         
                       
                setMode("resetPlayer") 
            break
            
            default,
                errOut("Invalid Download-State.")
                setMode("resetPlayer")
            break
        }
    }

    function void runParser()
    {
        if(!IsParsed)
        {   
            Status["status", string] = "Parsing Midi..."
            Status["progress", number] = ceil(MidiParsingProgress, 1)
            
            Data = Midi:decodeMidi(Speed)           
            IsParsed = parsingDone()               
        }
        else
        {
            if(Data["tracks", table]:count() > 6)
            {
                warOut("High amount of Tracks detected. Playback might fall out of sync.")   
            }

            Status["tracks", table] = Data["tracks", table]
            
            sucOut("Midi Parsed.")
            setMode("playMidi")   
        }
    }

    function void playNote(Note, Channel, Sound:string, Pitch, Volume, Duration, Sid)
    {
        if(!AvSpeakers:count())
        {
            if(!PowerSaving)
            {
                collectGarbage()
            }
        }  
        
        local SpeakerNumber = randint(1, AvSpeakers:count())
        local Speaker       = holoEntity(AvSpeakers[SpeakerNumber, number])
        
        Speaker:soundPlay(Sid, Duration, Sound)
        soundVolume(Sid, Volume)
        if(Pitch != 100)
        {
            soundPitch(Sid, Pitch)  
        }

        zChannel(Channel, Note, 0)

        AvSpeakers:remove(SpeakerNumber)
        
        local Expires = Duration

        Notes:pushTable(
                        table(
                            "speaker"=SpeakerNumber, 
                            "ncc"=(Note + Channel), 
                            "sid"=Sid, 
                            "pitch" = Pitch,
                            "volume" = Volume,
                            "channel" = Channel,
                            "starttime"=realtime(), 
                            "expiration"=(realtime() + Duration), 
                            "length"=(Duration + (1 * Channel == 10))
                            )
                        )
    }

    function void stopNote(Note, Channel)
    {
        if(Channel == 10)
        {
            return    
        }
        
        for(I = 1, Notes:count())
        {
            local NData = Notes[I, table]            
            if((Note + Channel) == NData["ncc", number])
            {
                local Duration = realtime() - NData["starttime", number]
 
                local Fade = clamp(Duration * max(1 - (Duration - NData["length", number]), 0.25), 0.25, max(Duration, 0.25))
                
                if(!PowerSaving)
                {
                    zChannel(Channel, 0, 0)
                }
                
                soundStop(NData["sid", number], Fade)
                Notes[I, table]["expiration", number] = realtime() + Fade + 0.25
                break   
            } 
        }   
    }

    function void playMidi()
    {     
        if(!IsPlaying)
        {
            resetSounds()

            Status["status", string] = "Playing Midi"

            StartTime  = realtime()
            IsPlaying  = 1           
            
            Playtime   = Data["header", table]["playtime", number]
            
            local Trks = Data["tracks", table]
            for(I = 1, Trks:count())
            {
                if(Trks[I, table]["events", table]:count() > 0)
                {
                    Counters[I, number] = 1                      
                }
            }           
        }
        else
        {    
            for(I = 1, Data["tracks", table]:count())
            {
                local Track  = Data["tracks", table][I, table]
                local Events = Track["events", table]   
                
                if(!Events:count() | Counters[I, number] >= Events:count())
                {
                    continue      
                }
                
                local Event  = Events[Counters[I, number], table]
                local Timing = Event["timing", number] 
                
                local LimitReached = (realtime() - StartTime) * TimeMult >= Timing 
                
                if(LimitReached)
                {
                    local Type  = Event["type",     string]
                    local Note  = Event["note",     number] + 1
                    local Chan  = Event["channel",  number] + 1
                    
                    if(Type == "Note On")
                    {
                        local Vol   = Event["volume",   number]
                        local Pitch = Event["pitch",    number]

                        playNote(Note, Chan, Event["sound", string], Pitch, Vol, Event["duration", number], Event["udid", number])                        
                    }
                    elseif(Type == "Note Off")
                    {
                        stopNote(Note, Chan)                              
                    }
                    elseif(Type == "Pitch Blend")
                    {        
                        #[                
                        local Blend = Event["increase", number]                 
                        
                        for(I = 1, Notes:count())
                        {
                            local NData = Notes[I, table]      
                            
                            if(NData["channel", number] - 1 == Event["channel", number])
                            {
                                soundPitch(NData["sid", number], clamp(NData["pitch", number] * (Blend), 1, 255))
                            }                            
                        }            
                        ]#            
                    }
                    elseif(Type == "Aftertouch")
                    {
                        local Pressure = Event["pressure", number]
                        
                        for(I = 1, Notes:count())
                        {
                            local NData = Notes[I, table]      
                            
                            if(NData["channel", number] - 1 == Event["channel", number])
                            {
                                soundVolume(NData["sid", number], clamp(NData["volume", number] + Pressure, 0, 1))
                            }                            
                        }                           
                    }

                    Counters[I, number] = Counters[I, number] + 1                                               
                }
            }
            
            Status["progress", number] = (realtime() - StartTime) * TimeMult #clamp(ceil((100 / Playtime) * ((realtime() - StartTime) * TimeMult), 1),0,100)           
             
            if((realtime() - StartTime) * TimeMult >= Playtime)
            {
                IsPlaying = 0 
                NoteCounter = 1
       
                if(!Loop)
                {
                    resetSounds()
                    hint("Playback finished", 3)
                    setMode("resetPlayer")  
                }                   
            }   
        }
    }

    function void resetPlayer()
    {
        halt()
        setMode("idle")  
    }

    function void init()
    {          
        while(HoloC < HoloCount & perf() & holoCanCreate())
        {        
            holoCreate(HoloC)
            holoParent(HoloC, entity())
            holoPos(HoloC, entity():toWorld(vec(0,0,11)))
            holoAlpha(HoloC, 0)
        
            HoloC = clamp(HoloC + 1, 1, HoloCount) 
        }       
        
        if(HoloC >= HoloCount)
        {
            while(ChannelC < 16 & perf() & holoCanCreate())
            {
                local I = HoloC + ChannelC + 1
                
                holoCreate(I, entity():toWorld(vec(-0.5,-7.5 + (15 / 15) * ChannelC,1.5)), vec(1,0.085,0.001), entity():toWorld(ang())) # z = 3.5
                holoMaterial(I, "debug/debugdrawflat")
                holoColor(I, hsv2rgb((360 / 16) * ChannelC, 1, 1))
                holoParent(I, entity())
                
                ChannelC++   
            }
                     
            if(ChannelC >= 16 & holoCanCreate())
            {                
                local I = HoloC + ChannelC + 1 

                holoCreate(I, entity():toWorld(vec(-0.5,0,1.45)), vec(1.1,1.4,0.001), entity():toWorld(ang())) # z = 3.45
                holoMaterial(I, "debug/debugdrawflat")
                holoColor(I, vec(40))
                holoParent(I, entity())
                
                
                sucOut("Initialized.")         
                setMode("idle")  
            }
        }         
    }
        
    function void idle()
    { 
        Status["status", string] = "Idle"
    }
    
    setMode("init")
}
elseif(last())
{
   # selfDestructAll()   
}

if(perf(OpsLimit))
{
    if(Mode != "init")
    {
        backgroundWorker()
    } 

    Mode()
}

if(Mode != "init")
{
    chatCommands()   
}

