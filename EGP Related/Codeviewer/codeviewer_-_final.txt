@name Codeviewer - Final
@inputs EGP:wirelink
@persist BuildSpeed OpsLimit LineIndex SlothDone SlothStep SlothSwapped IsLoading TotalTexts LineNumLen LineCounter InsideString Yield Stepper Evaluated ReadyToEvaluate ReadyToShow StringProgress 
@persist Continue OtherSpeed CurProgress DisplaySteps FuncsRetrieved DisplayingProg PrevY PrevLine PrevInd Fontsize Perf
@persist [FilePath StringBuilder FileContent CommentType CommentBuilder TextBuilder Console CurrentSnippet SnippetCopy ChatPrefix Font]:string
@persist [Syntax FileData]:table
@persist [SlothCopy LineBuilder FileLines CommentCollection VariableCollection FuncCollection Whitelist]:array
@persist [ ]:gtable
@persist [User]:entity
@persist [Cursor OldTextPos TextPos OldCursor]:vector2
@trigger none 

runOnChat(1)
runOnFile(1)
interval(100)

if( first() )
{
    # [ --- To Do --- ] #
    #[
        - Add Coloring via Chat 
        - Fix shitty type bug -.-
        - clean it the fuck up
        - make new sort that doesnt use for loops to iterate through items
        - add /open command for the owner to open a new file
        - prebuild text shit, so dont need to recreate it all the time. <--- big important 
    ]#
        
    # [ --- Config --- ] #
    ChatPrefix = "/"
    BuildSpeed = 1
    OtherSpeed = 1 # Better keep this at 1
    OpsLimit = 5000 #6500
    LineIndex = 1
    Font = "Courier New"
    Fontsize = 14
    FilePath = ">e2shared/base64.txt" #">e2shared/codeviewer_-_final.txt" #
    Perf = 20

    Syntax = table(
        "preproc" = table(
                        "col" = vec(240,240,160)
                        ),
                        
        "comments" = table(
                        "col" = vec(128)
                        ),
                        
        "strings" = table(
                        "col" = vec(150,150,150) #vec(150,150,180)
                        ),
    
        "keywords" = table(
                        "col" = vec(160,240,240),
                        "words" = array("function", "continue", "foreach", "default", "elseif", "return", "local", "break", "switch", "while", "case", "else", "for", "if")
                        ),
                        
        "uservariables" = table(
                        "col" = vec(160, 240, 160)
                        ),
                            
        "types" = table(
                        "col" = vec(240,160,96),
                        "words" = array("wirelink", "matrix2", "matrix", "matrix4", "gtable", "string", "vector2", "vector4", "array", "table", "gtable", "gTable", "angle", "vector", "entity", "number", "void", "normal", "bone", "quaternion")
                        ),
                        
        "numbers" = table(
                        "col" = vec(247,167,167)
                        ),
                        
        "userfunctions" = table(
                        "col" = vec(102,122,102)
                        ),
                        
        "e2functions" = table(
                        "col" = vec(160,160,240)
                        ),
                        
        "enums" = table(
                        "col" = vec(240,160,240)
                        ),
                        
        "ppcommands" = table(
                        "col" = vec(240,96,240),
                        "words" = array("#ifdef", "#endif", "#else")
                        ),                      
                        
        "default" = vec(255)
    )
    
    # [ --- Helpers --- ] #

    function array array:combSort()
    {
        local Step = This:count()
        local Copy = This
        local Swapped = 1
        while(Swapped | Step > 1)
        {
            Swapped = 0
            
            for(I = 1, Copy:count() - Step + 1)
            {
                if(Copy[I + 1, string]:length() > Copy[I, string]:length())
                {
                    local Store = Copy[I + 1, string]
                    Copy[I + 1, string] = Copy[I, string]
                    Copy[I, string] = Store
                    Swapped = 1   
                }       
            }    
            
            if(Step > 1)
            {
                Step = Step / 1.3   
            }
        }
        
        return Copy
    }

    function array array:bubbleSort()
    {
        local Temp = This

        for(A = 1, This:count())
        {
            for(B = 1, This:count() - 1)
            {
                if(Temp[B, string]:length() < Temp[B + 1, string]:length())
                {
                    local Store = Temp[B + 1, string]
                    Temp[B + 1, string] = Temp[B, string] 
                    Temp[B, string] = Store
                }
            }
        }
        
        return Temp          
    }

    function table table:bubbleSort()
    {
        local Temp = This

        for(A = 1, This:count())
        {
            for(B = 1, This:count() - 1)
            {
                if(Temp[B, table]["distance", number] < Temp[B + 1, table]["distance", number])
                {
                    local Store = Temp[B + 1, table]
                    Temp[B + 1, table] = Temp[B, table] 
                    Temp[B, table] = Store
                }
            }
        }
        
        return Temp          
    }

    function number prevention()
    {
        return perf(Perf) & ops() < OpsLimit   
    }
    
    SlothDone = 0
    SlothStep = -1
    SlothCopy = array()
    SlothSwapped = -1   
    function array array:slothSortA() # combSort but slow
    {
        if(SlothStep == -1 | !SlothCopy:count() | SlothSwapped == -1)
        {
            SlothDone = 0
            SlothStep = This:count()  
            SlothCopy = This    
            SlothSwapped = 1   
        }
        
        if(prevention())
        {
            if(clk("sloth"))
            {            
                if(SlothSwapped | SlothStep > 1)
                {
                    SlothSwapped = 0
                    
                    for(I = 1, SlothCopy:count() - SlothStep + 1)
                    {
                        if(SlothCopy[I + 1, string]:length() > SlothCopy[I, string]:length())
                        {
                            local Store = SlothCopy[I + 1, string]
                            SlothCopy[I + 1, string] = SlothCopy[I, string]
                            SlothCopy[I, string] = Store
                            SlothSwapped = 1   
                        }       
                    }    
                    
                    if(SlothStep > 1)
                    {
                        SlothStep = SlothStep / 1.3   
                    }
                }
                
                if(SlothSwapped == 0 & SlothStep < 1)
                {
                    SlothDone = 1    
                }
                else
                {
                    timer("sloth", 10)   
                }
            }
            else
            {
                timer("sloth", 10)                  
            }
        }
        
        if(SlothDone)
        {       
            SlothStep = -1
            return SlothCopy   
        }             
        
        return array() 
    }

    function array array:slothSortB() # combSort but slow
    {
        if(SlothStep == -1 | !SlothCopy:count() | SlothSwapped == -1)
        {
            SlothDone = 0
            SlothStep = This:count()  
            SlothCopy = This    
            SlothSwapped = 1   
        }
        
        while(prevention())
        {          
            if(SlothSwapped | SlothStep > 1)
            {
                SlothSwapped = 0
                
                for(I = 1, SlothCopy:count() - SlothStep + 1)
                {
                    if(SlothCopy[I + 1, string]:length() > SlothCopy[I, string]:length())
                    {
                        local Store = SlothCopy[I + 1, string]
                        SlothCopy[I + 1, string] = SlothCopy[I, string]
                        SlothCopy[I, string] = Store
                        SlothSwapped = 1   
                    }       
                }    
                
                if(SlothStep > 1)
                {
                    SlothStep = SlothStep / 1.3   
                }
            }
            
            if(SlothSwapped == 0 & SlothStep < 1)
            {
                SlothDone = 1    
            }
        }
        
        if(SlothDone)
        {       
            SlothStep = -1
            return SlothCopy   
        }             
        
        return array() 
    }
    
    function array array:slothSort()
    {
        if(This:count() > 50)
        {
            return This:slothSortA()    
        }
        elseif(This:count() > 10)
        {
            return This:slothSortB()   
        }
        else
        {
            return This:combSort()   
        }   
    }

    function number chat(Command:string)
    {
        local Result = chatClk(User) & User:lastSaid():explode(" ")[1, string] == (ChatPrefix + Command)
        if(User == owner() & Result){ hideChat(1) }
        return Result
    }
    
    function number oChat(Command:string)
    {
        local Result = chatClk(owner()) & owner():lastSaid():explode(" ")[1, string] == (ChatPrefix + Command)
        if(Result){ hideChat(1) }
        return Result           
    }

    Whitelist = array()
    function void whitelistUser(Player:string)
    {
        Whitelist:pushString(Player)
    }
    
    function void blacklistUser(Player:string)
    {
        local Copy = array()
        foreach(W, Whitelisted:entity = Whitelist)
        {
            if(Whitelisted:steamID() != Player)
            {
                Copy:pushString(Whitelisted:steamID())   
            }   
        }
        Whitelist = Copy
    }
    
    function number onWhitelist(Player:string)
    {
        for(I = 1, Whitelist:count())
        {
            if(Whitelist[I, string] == Player)
            {
                return 1
            }   
        }       
                
        return 0
    }

    function number getProgress(Percent)
    {
        return floor((250 / 100) * Percent)
    }
    
    function void setProgress(Progress)
    {
        EGP:egpSize(16, vec2(getProgress(Progress), 30))           
    }    
    
    function void showLoading()
    {
        setProgress(0)   
        
        EGP:egpAlpha(15, 255)
        EGP:egpAlpha(16, 255)
        EGP:egpAlpha(17, 255)              
    }
    
    function void hideLoading()
    {
        EGP:egpAlpha(15, 0)
        EGP:egpAlpha(16, 0)
        EGP:egpAlpha(17, 0)     
        
        setProgress(0)                     
    }
    
    function number useDown()
    {
        if(User:keyUse() & User:aimEntity() == EGP:entity())  
        {
            return 1   
        }
        
        return 0
    }
    
    function number clicked(Element)
    {
        return inrange(Cursor, EGP:egpPos(Element) - EGP:egpSize(Element), EGP:egpPos(Element) + EGP:egpSize(Element))           
    }
    
    function string ws(Size:string)
    {
        local B = ""
        foreach(I, S:string = Size:explode(""))
        { 
            B += (S != "\n" ? " " : "\n")
        } 
        return B 
    }
   
    function number string:isUpper()
    {
        local B = toByte(This)        
        if(B >= 65 & B <= 90){ return 1 }            
        return 0
    }
    
    function number string:isLower()
    {
        local B = toByte(This)        
        if(B >= 97 & B <= 122){ return 1 }            
        return 0        
    }
    
    function number string:isLetter()
    {
        if(This:isLower() | This:isUpper()){ return 1 }                  
        return 0        
    }
    
    function number string:isNumber()
    {
        local B = toByte(This)     
        if(B >= 48 & B <= 57){ return 1 }                
        return 0   
    }
 
    function number string:isSpecial()
    {
        if(!This:isLetter() & !This:isNumber()){ return 1 }           
        return 0
    }

    function number string:isWhitespace()
    {
        if(This:replaceRE("%s", "") == ""){ return 1 }               
        return 0      
    }

    function number array:exists(S:string)
    {
        foreach(I, N:string = This)
        {
            if(N == S){ return 1 }       
        }   
        
        return 0
    }

    function array array:removeDuplicates()
    {
        local Result = array()
        
        foreach(I, Value:string = This)
        {
            if(!Result:exists(Value))
            {
                Result:pushString(Value)   
            }   
        }   
        
        return Result
    }

    function void newText(Index, Text:string, Col:vector)
    {       
        if(!EGP:egpHasObject(Index))
        {
            EGP:egpTextLayout(Index, Text, vec2(6, 5 ), vec2(9999))     
            EGP:egpSize(Index, Fontsize)
            EGP:egpColor(Index, Col)   
            EGP:egpFont(Index, Font) 
            EGP:egpParent(Index, 251)
        }
        else
        {
            EGP:egpSetText(Index, Text)   
            EGP:egpFont(Index, Font) 
            EGP:egpColor(Index, Col)  
        }   
          
        EGP:egpAlpha(Index, 0)
    } 
    
    function void hideText(Index)
    {   
        for(I = Index, TotalTexts - 1)
        {
            EGP:egpAlpha(I, 0)   
        }
    }
    
    function void showText(Index)
    {
        for(I = Index, TotalTexts - 1)
        {
            EGP:egpAlpha(I, 255)   
        }   
    }

    function void showConsole()
    {
        EGP:egpAlpha(19, 255)    
    }
    
    function void hideConsole()
    {
        EGP:egpAlpha(19, 0) 
    }
    
    function void writeConsole(Msg:string)
    {
        local Result = ""
        local Lines = Console:explode("\n")
        
        for(I = 2, 10)
        {
            Result += (I < 10 ? Lines[I, string] : "> " + Msg) + "\n"
        }
               
        Console = Result
        
        EGP:egpRemove(19)
        EGP:egpTextLayout(19, Console, vec2(5, 330), vec2(999, 999))   
        EGP:egpColor(19, vec(125,125,140))
        EGP:egpAlpha(19, 255)
     #   EGP:egpFont(19, "Lucida Console")
        EGP:egpFont(19, Font)
    }
        
    function void clearConsole()
    {
        Console = "\n":repeat(10)
        EGP:egpRemove(19)
        EGP:egpTextLayout(19, Console, vec2(5, 330), vec2(999, 999))   
        EGP:egpColor(19, vec(125,125,140))
        EGP:egpAlpha(19, 255)
     #   EGP:egpFont(19, "Lucida Console")        
        EGP:egpFont(19, Font)
    }
    
    function void loadFile(Path:string)
    {
        fileLoad(Path)
        IsLoading = 1   
    }
    
    function string readFile()
    {
        if(!fileLoading())
        {
            IsLoading = 0
            return fileRead()
        }    
        
        return ""
    }
      
    function void setProgress(Type:string, Current, Maximum)
    {
        local Percentage = floor((100 / Maximum) * Current, 1)
        setName("[ Sixmax' Codeviewer Beta ]\n[Workload]: " + Type + "\n[Progress]: " + Percentage + "%")   
    }

    function vector col4Key(Key:string)
    {  
        if(Key == "nil")
        {
            return Syntax["default", vector]   
        }
        
        return Syntax[Key, table]["col", vector]
    }
        
    function array words4Key(Key:string)
    {
        return Syntax[Key, table]["words", array]
    }

    function array table:toArr()
    {
        local Result = array()
        foreach(I, Key:number = This:keys())
        {
            local Dir = This[Key, array][1, string]
            
            if(!Result:exists(Dir))
            {
                Result:pushString(Dir)
            }
        }
        return Result 
    }
    
    # [ ----------------------------------------------------------------- ] #
                    # [ --- Main Functions --- ] #

    function string string:getPreprocType()
    {      
        local Sub = This:sub(1,2)   
        if(Sub == "@n")
        {
            return "name"
        }        
        elseif(Sub == "@t")
        {
            return "trigger"   
        }
        elseif(Sub == "@m")
        {
            return "model"   
        }
        elseif(Sub == "@o")
        {
            return "outputs"
        }
        elseif(Sub == "@i")
        {
            return "inputs"   
        }
        elseif(Sub == "@p")
        {
            return "persist"   
        }        
    
        return ""
    }
    
    function array array:findPreprocSnippets()
    {
        local Result = array()
        
        foreach(L, Line:string = This)
        {
            local NoSpace = Line:replaceRE("%s", "")
            
            if(NoSpace == "")
            {
                continue
            }
            
            if(NoSpace:sub(1,1) == "@")
            {
                local Type = NoSpace:getPreprocType()
                
                if(Type == "trigger" | Type == "model" | Type == "name")
                {
                    Result:pushString(Line)  
                    continue 
                }             

                Result:pushString("@" + Type)                   
            }
            else
            {
                if(!NoSpace:sub(1,1):isSpecial())
                {
                    break   
                }
            }
        }
        
        return Result   
    }

    function array array:findCommentsSlowly()
    {       
        while(LineCounter < This:count() & prevention())
        { 
            local Line = This[LineCounter, string]

            if(!Line:find("#"))
            {
                if(CommentType == "multi")
                {
                    CommentBuilder += Line + "\n"
                }
            }
            else
            {            
                local Chars = Line:explode("")
               
                foreach(I, Char:string = Chars)
                {
                    # [ --- Identify Comment Type --- ] #
                    if(CommentType == "nil")
                    {                                     
                        if(Char == "#")  
                        {
                            local NextChar = Chars[I + 1, string]
                            
                            if(NextChar == "[")
                            {
                                CommentType = "multi"              
                            }                   
                            else
                            {
                                CommentType = "single"      
                            }    
                        }
                    }
                    # [ ----------------------------- ] #
                    
                    # [ --- Handle all the inline stuff --- ] #
                    if(CommentType == "single")
                    {
                        CommentBuilder += Char                  
                    }
                    elseif(CommentType == "multi")
                    {
                        CommentBuilder += Char
                        
                        if(Char == "#")
                        {
                            local PrevChar = Chars[I - 1, string]
                            
                            if(PrevChar == "]")
                            {
                                if(!CommentCollection:exists(CommentBuilder))
                                {
                                    CommentCollection:pushString(CommentBuilder)       
                                }
                                
                                CommentBuilder = "" 
                                CommentType = "nil"                               
                            } 
                        }               
                    }
                    # [ ----------------------------------- ] #
                }
                
                if(CommentType == "single")
                {
                    # A single comment can only be in 1 line, so reset everything when a new line starts, but save the comment.
                    if(!CommentCollection:exists(CommentBuilder))
                    {
                        CommentCollection:pushString(CommentBuilder)       
                    }
                    CommentBuilder = "" 
                    CommentType = "nil" 
                }
                elseif(CommentType == "multi")
                {
                    CommentBuilder += "\n" # If the comment is still in multi, it means another line has started. So make a new line.
                }
            }
            
            LineCounter++
        }
        
        if(LineCounter >= This:count())
        {
            Continue = 1
                
            if(CommentType != "nil")
            {
                if(!CommentCollection:exists(CommentBuilder))
                {
                    CommentCollection:pushString(CommentBuilder)       
                }
            }    
            
            return CommentCollection
        }
        
        
        return array()
    }

    function array array:findStringsPerfed()
    {
        while(LineCounter < This:count() & prevention())
        {
            local Line = This[LineCounter, string]
            
            if(!Line:find("\""))
            {
                if(InsideString)
                {
                    StringBuilder += Line + "\n"
                } 
            }
            else
            {            
                local Chars = Line:explode("")
                
                foreach(I, Char:string = Chars)
                {
                    if(!InsideString)
                    {
                        local PrevChar = Chars[I - 1, string]
                        
                        if(Char == "\"" & PrevChar != "\\") 
                        {
                            InsideString = 1 
                        } 
                    }     
                    else
                    {                  
                        StringBuilder += Char
                        
                        local NextChar = Chars[I + 1, string]
                        local PrevChar = Chars[I - 1, string]
         
                        if(Char == "\"" & PrevChar != "\\")
                        {
                            StringBuilder = "\"" + StringBuilder
                            
                            if(!LineBuilder:exists(StringBuilder))
                            {
                                LineBuilder:pushString(StringBuilder)
                            }
                            
                            StringBuilder = ""  
                            InsideString = 0 
                        }       
                    }    
                } 
                
                if(InsideString)
                {
                    StringBuilder += "\n"   
                }  
            }
            
            LineCounter++
        }

        if(LineCounter >= This:count())
        {           
            if(InsideString)
            {
                if(!LineBuilder:exists(StringBuilder))
                {
                    LineBuilder:pushString(StringBuilder)  
                }     
            }      
            
            if(!LineBuilder:count())
            {
                Continue = 1   
            }
   
            return LineBuilder             
        }        
        
        return array()
    }
    
    function array string:gfindVariables()
    {
        local Result = This:gmatch("_?[A-Z][a-zA-Z0-9]*:?"):toArr()
        local Others = This:gmatch("_?[A-Z][a-zA-Z0-9]*_*[A-Z][a-zA-Z0-9]*_*[A-Z][a-zA-Z0-9]*_*[A-Z][a-zA-Z0-9]*_*[A-Z][a-zA-Z0-9]*_*[A-Z][a-zA-Z0-9]*_*[A-Z][a-zA-Z0-9]*_*[A-Z][a-zA-Z0-9]*_*[A-Z][a-zA-Z0-9]*_*[A-Z][a-zA-Z0-9]*"):toArr()
        local Result = Result:merge(Others)
        return Result   
    }
    
    function number string:hasVariables()
    {
        return This:findRE("_?%u[%l%u%d_]*")   
    }
    
    function array string:gfindE2Functions()
    {
        local Functions = This:gmatch(":?[a-z][a-zA-Z0-9]*%("):toArr()
 
        if(!Functions:count())
        {
            return array()   
        }
        
        local Result = array()
        
        foreach(I, Function:string = Functions)
        {            
            local Func = Function:replaceRE("[%s|(|:]", "")
            
            if(!Result:exists(Func))
            {
                Result:pushString(Func)   
            }   
        }
        
        return Result  
    }

    function array array:gfindE2FunctionsPerfed()
    {        
        while(LineCounter < This:count() & prevention())
        {
            local Line = This[LineCounter, string]

            local Functions = Line:gmatch(":?[a-z][a-zA-Z0-9]*%("):toArr()
     
            if(Functions:count() > 0)
            {                
                foreach(I, Function:string = Functions)
                {            
                    local Func = Function:replaceRE("[%s|(|:]", "")
                    
                    if(!FuncCollection:exists(Func))
                    {
                        FuncCollection:pushString(Func)   
                    }   
                }                    
            }
            
            LineCounter = LineCounter + 1      
        }
        
        if(LineCounter >= This:count())
        {
            LineCounter = 0
            local Save = FuncCollection   
            FuncCollection = array()
            return Save
        }
        
        return array()  
    }
    
    function array string:gfindUserFunctions()
    {
        local Functions = This:gmatch("function [a-z]*[a-z|A-Z|0-9]*[ ]?[a-z]*[a-z|A-Z|0-9]*[:| ]?[a-z][a-z|A-Z|0-9]*", 1):toArr()

        if(!Functions:count())
        {
            return array()   
        }
        
        local Result = array()
        
        foreach(I, Function:string = Functions)
        {
            if(Function:sub(1,1) == "_")
            {
                continue   
            }
            
            local Func = Function:replaceRE("function[ ]?[a-z]*[a-z|A-Z|0-9]*[ ]?[a-z]*[a-z|A-Z|0-9]*[:| ]", "")     
            if(!Result:exists(Func))
            {       
                Result:pushString(Func)  
            }                
        }
          
        return Result
    }
    
    function array array:removeFromeach(Input:string)
    {
        if(Input:length() <= 1)
        {
            return array()    
        }
        
        local Result = array()
        
        foreach(A, Word:string = This)
        {
            Result:pushString(Word:replaceRE(Input, ""))
        }   
        
        return Result
    }
    
    function array string:gfindEnums()
    {
        return This:gmatch("[(|:|%s|]*_[A-Z]*[A-Z0-9]+_*[A-Z0-9]*_*[A-Z0-9]*_*[A-Z0-9]*_*[A-Z0-9]*_*[A-Z0-9]*_*[A-Z0-9]*_*[A-Z0-9]*_*[A-Z0-9]*_*[A-Z0-9]*", 1):toArr()
    }

    function string string:removeNumbers()
    {   
        return This:replaceRE("%d%.%d", "   "):replaceRE("[0-9]", " ")
    }
    
    function string array:getTextSnippet(StartLine, EndLine)
    {  
        local Block = ""
        foreach(L, Line:string = This)
        {
            if(L < StartLine)
            {
                continue   
            }   
            elseif(L > EndLine)
            {
                break   
            }
            else
            {
                Block += Line + "\n"
            }
        }

        return Block
    }
    function string string:removeFromText(Input:array)
    {             
        local Constructor = This
            
        foreach(I, Black:string = Input)
        {
            Constructor = Constructor:replace(Black, ws(Black))
        }    
        
        return Constructor    
    }

    function void resetAll()
    {
        LineCounter = 0
        InsideString = 0
        LineBuilder = array()
        StringBuilder = ""        
        Continue = 0

        CommentType = "nil"
        CommentBuilder = ""
        CommentCollection = array()
        Yield = 0
        VariableCollection = array()
        SlothDone = 0
        SlothStep = -1
        SlothCopy = array()
        SlothSwapped = -1     
        FuncsRetrieved = 0 
    }

    function number evaluateData(Lines:array, Content:string)
    {
        local Progress = 0 # Von 0 -> 1
        
        if((clk("eval") | Yield) & prevention())
        {
            switch(Stepper)
            {
                case 0,
                if(1)
                {
                    local Preproc = Lines:findPreprocSnippets()   
                    
                    if(Preproc:count() > 0)
                    {
                        Preproc = Preproc:removeDuplicates():bubbleSort() 
                    }
                    
                    FileData["preproc", array] = Preproc              
                    Progress = 0.1
                    
                    writeConsole("Preprocessor cached")
            
                    resetAll()
                }
                break
                
                case 1,
                if(1)
                {
                    Yield = 1                
                    local Strings = Lines:findStringsPerfed()                

                    Progress = 0.1 + ((0.2 / Lines:count()) * LineCounter)

                    local Count = Strings:count() > 0               
                    if(Count | Continue)
                    {
                        if(changed(Strings:count() > 75) & Strings:count() > 75)
                        {
                            writeConsole("High amount of Strings("+Strings:count()+") detected.\nInitiating slow sorting...")  
                        } 
                    
                        if(Count)
                        {
                            local Sorted = Strings:slothSort()   
                            
                            if(Sorted:count() > 0)
                            {
                                FileData["strings", array] = Sorted         
                                resetAll()
                                writeConsole("Strings cached")
                            }
                        }           
                        else
                        {                          
                            FileData["strings", array] = Strings                               
                            resetAll()
                            writeConsole("Strings cached")
                        }
                    }
                }
                break   
                
                case 2,
                if(1)
                {
                    Yield = 1
                    local Comments = Lines:findCommentsSlowly()
                    
                    Progress = 0.3 + ((0.2 / Lines:count()) * LineCounter)   

                    local Count = Comments:count() > 0
                    if(changed(Comments:count() > 75) & Comments:count() > 75)
                    {
                        writeConsole("High amount("+Comments:count()+") of Comments detected.\nInitiating slow sorting...")  
                    } 

                    if(Count | Continue)
                    {    
                        if(Count)
                        {
                            local Sorted = Comments:slothSort()   
                            
                            if(Sorted:count() > 0)
                            {
                                FileData["comments", array] = Sorted                                                    
                                writeConsole("Comments cached")                                    
                                resetAll()                                
                            }
                        }
                        else
                        {                                     
                            FileData["comments", array] = Comments                                                    
                            writeConsole("Comments cached")                                    
                            resetAll()
                        }
                    } 
                }                
                break

                case 3,
                if(1)
                {
                    FileData["enums", array] = Content:gfindEnums()
                    if(FileData["enums", array]:count() > 1)
                    {
                        FileData["enums", array] = FileData["enums", array]:removeDuplicates():removeFromeach("[%(|:|%s| ]"):bubbleSort()
                    }
                    Progress = 0.55
                    writeConsole("Enums cached")                
                }
                break
            
                case 4,
                if(1)
                {
                    Yield = 1                
                    while(LineCounter < Lines:count() & prevention())
                    {
                        local Line = Lines[LineCounter, string]
                        
                        local Faster = 1                                                 
                        if(Line:hasVariables())
                        {
                            local VarsInLine = Line:gfindVariables()                            
                            foreach(V, Var:string = VarsInLine)
                            {
                                local FixedVar = Var:replace(":", "")
                                if(!VariableCollection:exists(FixedVar) & FixedVar:sub(1,1) != "_")
                                {
                                    VariableCollection:pushString(FixedVar) 
                                }   
                            }                                                    
                            Faster = 0
                        }
                        
                        LineCounter++                
                        
                        Progress = 0.55 + ((0.2 / Lines:count()) * LineCounter)                
                    }

                    if(LineCounter >= Lines:count())
                    {          
                        if(VariableCollection:count() > 30)
                        {
                            local Sorted = VariableCollection:slothSort()                                    
                            local Sta = VariableCollection:count() > 30                                
                            if(changed(Sta) & Sta)
                            {
                                writeConsole("High amount("+VariableCollection:count()+") of Variables detected.\nInitiating slow sorting...")
                            }
                            
                            if(Sorted:count() > 0)
                            {
                                writeConsole("Variables cached")                       
                                FileData["uservariables", array] = Sorted
                                resetAll()             
                            }
                        }
                        else
                        {                            
                            writeConsole("Variables cached")
                            FileData["uservariables", array] = VariableCollection:bubbleSort()
                            resetAll()            
                        }
                    }                                                   
                }
                break

                case 5,
                FileData["userfunctions", array] = Content:gfindUserFunctions()    
                Progress = 0.7825                
                break
                
                case 6,
                if(1)
                {                         
                    if(FileData["userfunctions", array]:count() > 1)
                    {
                        local Temp = FileData["userfunctions", array]:slothSort()       
                        
                        if(Temp:count() > 0)
                        {
                            FileData["userfunctions", array] = Temp    
                            Progress = 0.80                      
                            writeConsole("Userfunctions cached")
                            resetAll()
                        }
                    }
                    else
                    {
                        Progress = 0.80                      
                        writeConsole("Userfunctions cached")
                        resetAll()
                    }
                }
                break
                
                case 7,
                if(1)
                {
                    if(!FuncsRetrieved)
                    {
                        Yield = 1
                        local EFuncs = Lines:gfindE2FunctionsPerfed() 
                       
                        if(EFuncs:count() > 0)
                        {
                            writeConsole("E2Functions retrieved")
                            FileData["e2functions", array] = EFuncs
                            FuncCollection = array()
                            FuncsRetrieved = 1
                        }
                    }
                    
                    if(FuncsRetrieved)
                    {                    
                        local Stas = FileData["e2functions", array]:count() > 20
                        
                        if(changed(Stas) & Stas)
                        {
                            writeConsole("High amount("+FileData["e2functions", array]:count()+") of E2Functions detected.\nInitiating slow sorting...")       
                        }
                        
                        if(Stas)
                        {
                            local Sorted = FileData["e2functions", array]:slothSort()    
                            
                            if(Sorted:count() > 0)
                            {
                                FileData["e2functions", array] = Sorted

                                Progress = 0.90
                                writeConsole("E2Functions cached")
                                
                                resetAll()
                            }       
                        }
                        else
                        {
                            Yield = 0
                            FileData["e2functions", array] = FileData["e2functions", array]:bubbleSort()           
                            resetAll()
                            writeConsole("E2Functions cached")
                        }
                    }
                }
                break
                
                case 8,
                    local Result = array()
                    foreach(T, Tem:string = FileData["e2functions", array])
                    {
                        if(!FileData["userfunctions", array]:exists(Tem))
                        {
                            Result:pushString(Tem)     
                        }   
                    }
                    FileData["e2functions", array] = Result
                    Progress = 0.95
                    writeConsole("Caching check completed")
                break
                
                case 9,
                    writeConsole("Data cached")
              #      gCache(FilePath)
                break
                
                default,
                    Progress = 1
                    resetAll()
                    Stepper = 0
                break
            }
            
            if(!Yield)
            {
                Stepper++   
                timer("eval", BuildSpeed)
            }   
        }
        else
        {
            timer("eval", BuildSpeed)   
        }        
        
        return Progress
    }
    
    # [ --- EGP garbage --- ] #
    function void initEGP()
    {
        EGP:egpClear()
        EGP:egpDrawTopLeft(1) 
                              
        EGP:egpCircle(250, vec2(0,0), vec2(1,1))
        EGP:egpCircle(251, vec2(0,0), vec2(1,1))
                                                               
        local ScreenCenter = vec2(256,256)          

        # [ --- Background --- ] #
        EGP:egpBox(18, vec2(0,0), vec2(512,512))
        EGP:egpColor(18, vec(45,45,45))
    
        
        # 62
        
        # [ --- Progressbar --- ] #
        local BarProgress = 50
        local BarPos = ScreenCenter - vec2(125, 15)
        
        EGP:egpBox(15, BarPos, vec2(250,30)) # Bar Background
        EGP:egpColor(15, vec(225,85,85))
        
        EGP:egpBox(16, BarPos, vec2(getProgress(0), 30))
        EGP:egpColor(16, vec(87,85,221)) # Bar Progress
        
        EGP:egpBoxOutline(17, BarPos, vec2(250,30))    
        EGP:egpColor(17, vec(160,160,240)) # Bar Outline
        
        EGP:egpAlpha(15, 0)
        EGP:egpAlpha(16, 0)
        EGP:egpAlpha(17, 0)       
        
        # [ --- Errorbox --- ] #

        # [ --- Cursor --- ] #
        EGP:egpCircle(4321, vec2(-10,-10), vec2(2, 2))
        EGP:egpColor(4321, vec(139,64,140))
        EGP:egpParentToCursor(4321)                
        
        # [ --- Console --- ] #
        clearConsole()
    }
    
    function string string:text(Index, Table:table, Key:string)
    {
        local Removal = Table[Key, array]
        if(Removal:count() > 0)
        {
            newText(Index, This, col4Key(Key))
            return This:removeFromText(Removal)
        }     
        
        return This 
    }
    
    function string string:removeTypes(Types:array)
    {
        local Temp = This
        foreach(T, Type:string = Types)
        {
            Temp = Temp:replaceRE("[^a-zA-Z0-9]" + Type, ws(Type)) 
        }
        return Temp
    }

    function string reloadOtherTextShit()
    {
        local Highest = 1
        local LineNumber = ""
        for(I = LineIndex, ceil(LineIndex + 512 / Fontsize) - 2)
        {
            LineNumber += I + "\n"   
            if(I > Highest)
            {
                Highest = I   
            }
        }
        
        LineNumLen = Fontsize * Highest:toString():length()
        return LineNumber
    }
    
    function void reloadTextAssets()
    {
        local LineNumber = reloadOtherTextShit()
        
        local Y = LineNumLen / Fontsize      
        
        if(!EGP:egpHasObject(32))
        {
            EGP:egpBox(32, vec2(0,0), vec2(LineNumLen - Y, 512))
            EGP:egpColor(32, vec(60,60,60))     
        } 
        else
        {
            EGP:egpSize(32, vec2(LineNumLen - Y, 512))   
        }
         
        if(!EGP:egpHasObject(33)) 
        {
            EGP:egpTextLayout(33, LineNumber, vec2(0, 0), vec2(512, 512))
            EGP:egpFont(33, "Lucida Console")
            EGP:egpSize(33, Fontsize)
            EGP:egpColor(33, vec(125,125,160))     
        }
        else
        {
            EGP:egpSetText(33, LineNumber)
            EGP:egpSize(33, Fontsize)               
        }
    }

    DisplaySteps = 0
    function number displayLines()
    {                
        if(SnippetCopy == "")
        {
            SnippetCopy = CurrentSnippet
            DisplaySteps = -1
        }
        
        while(DisplaySteps <= 10 & prevention())
        {
            switch(DisplaySteps)
            { 
                case 0,           
                    for(I = 31, 20, -1)
                    {
                        EGP:egpAlpha(I, 0)
                    }
                    SnippetCopy = SnippetCopy:text(20, FileData, "preproc") 
                    DisplaySteps++
                break
                
                case 1, 
                    SnippetCopy = SnippetCopy:text(21, FileData, "strings") 
                    DisplaySteps++
                break

                case 2,
                    local Dir = "ppcommands"
                    local Removal = Syntax[Dir, table]["words", array]
                    if(Removal:count() > 0)
                    {
                        newText(23, SnippetCopy, col4Key(Dir))
                        SnippetCopy = SnippetCopy:removeFromText(Removal)
                    }

                    DisplaySteps++   
                break
                
                case 3, 
                    SnippetCopy = SnippetCopy:text(22, FileData, "comments") 
                    DisplaySteps++
                break
        
                case 4,
                    Dir = "keywords"
                    Removal = Syntax[Dir, table]["words", array]
                    if(Removal:count() > 0)
                    {
                        newText(24, SnippetCopy, col4Key(Dir))
                        SnippetCopy = SnippetCopy:removeFromText(Removal)
                    } 
                    DisplaySteps++                
                break
        
                case 5,
                    Dir = "types"
                    Removal = Syntax[Dir, table]["words", array]
                    if(Removal:count() > 0)
                    {
                        newText(25, SnippetCopy, col4Key(Dir))
                        SnippetCopy = SnippetCopy:removeFromText(Removal)
                    } 

                    DisplaySteps++

                    SnippetCopy = SnippetCopy:text(29, FileData, "enums")
                break
     
                case 6, 
                    SnippetCopy = SnippetCopy:text(26, FileData, "e2functions")
                    DisplaySteps++
                break
                
                case 7, 
                    SnippetCopy = SnippetCopy:text(27, FileData, "userfunctions") 
                    DisplaySteps++
                break                                                                       

                case 8, 
                    SnippetCopy = SnippetCopy:text(28, FileData, "uservariables") 
                    DisplaySteps++
                break   
    
                case 9,  
                    newText(30, SnippetCopy, col4Key("numbers"))   
                                 
                    SnippetCopy = SnippetCopy:removeNumbers() 
                    newText(31, SnippetCopy, col4Key("nil"))
                    
                    DisplaySteps++
                break         

                case 10,                   
                    reloadTextAssets()
                    DisplaySteps++
                break
                
                default,
                    DisplaySteps++
                break
            }
        }
        
        if(DisplaySteps >= 10)
        {
            for(I = 31, 20, -1)
            {
                EGP:egpAlpha(I, 255)
            }

            DisplaySteps = -1
            SnippetCopy = CurrentSnippet
            return 1       
        }
        
        return 0
    }
    
    function void reloadScript()
    {
        SnippetCopy = CurrentSnippet
        DisplaySteps = -1
        DisplayingProg = 0      

        for(I = 20, 31)
        {
            EGP:egpAlpha(I, 0)
        }
    }

    function void reloadView()
    {
        EGP:egpPos(250, vec2(EGP:egpPos(250)[1], -(LineIndex * Fontsize)))                
        CurrentSnippet = FileLines:getTextSnippet(LineIndex, ceil(LineIndex + 512 / Fontsize) - 2)
        reloadScript()      
    }
    
    # [ --- Data Initialization --- ] #
    FileData = table(
        "preproc" = array(), # done
        "comments" = array(), # done 
        "strings" = array(), # done 
        "uservariables" = array(), # done
        "userfunctions" = array(), # done
        "e2functions" = array(), # 
        "enums" = array() # done
    )
    
    Evaluated = 0
    ReadyToEvaluate = 0

    if(!entity():isWeldedTo():isValid() | entity():isWeldedTo():type() != "gmod_wire_egp")
    {
        print(_HUD_PRINTCENTER, "Place your E2 on an EGP screen or connect its wirelink")
    }
}


if(!EGP:entity())
{
    local PossibleEGP = entity():isWeldedTo()
    if(PossibleEGP != noentity())
    {
        if(PossibleEGP:type() == "gmod_wire_egp")
        {
            EGP = PossibleEGP:wirelink()        
        }
    }
}

if(changed(EGP:entity()) & EGP:entity())
{    
    initEGP()
    loadFile(FilePath)   
}

if(fileLoaded() & prevention())
{
    if(EGP:entity() & ReadyToEvaluate == 0 & IsLoading)
    {
        FileContent = readFile()
        FileLines = FileContent:explode("\n")    
        ReadyToEvaluate = 1
    }

    if(changed(ReadyToEvaluate) & ReadyToEvaluate)
    {
        showConsole()
        showLoading()
        Evaluated = 0
        # Debug area
    }
    
    if(!Evaluated)
    {
        local Progress = evaluateData(FileLines, FileContent)                     
        CurProgress = Progress > CurProgress ? Progress : CurProgress
        setProgress(CurProgress * 100)           
        Evaluated = floor(CurProgress)
    }
    else
    {
        if(DisplayingProg == 0)
        {
            DisplayingProg = displayLines()    
        }
        
        if(useDown())
        {
            local Pos =  (Cursor - OldTextPos) + TextPos
            Pos = vec2(floor(Pos[1]), floor(Pos[2]))      
                  
            local ClampedPos = vec2()

            if(Pos[2] > PrevY + Fontsize | Pos[2] < PrevY - Fontsize)
            {    
                LineIndex = max(floor((-Pos[2]) / Fontsize) + 1, 1)#, FleLines:count() - 250 / Fontsize)
                ClampedPos[2] = Pos[2]  
                PrevY = ClampedPos[2]  
            }
            else
            {
                ClampedPos[2] = PrevY      
            }
            
            ClampedPos[1] = Pos[1]

            EGP:egpPos(250, clamp(ClampedPos, vec2(-999999999,(-FileLines:count() * Fontsize) + 500), vec2(LineNumLen,0)))  

            if(!EGP:egpHasObject(252))
            {
                EGP:egpBox(252, vec2(0,Cursor[2]),vec2(512,3))
                EGP:egpAlpha(252, 75)
            }
            else
            {
                local IndiciatorPos = floor(Cursor[2])
                
                if(IndiciatorPos > PrevInd + Fontsize | IndiciatorPos < PrevInd - Fontsize)
                {
                    IndiciatorPos = Cursor[2]
                    PrevInd = IndiciatorPos 
                }
                else
                {
                    IndiciatorPos = PrevInd    
                }
                
                EGP:egpPos(252, vec2(0, IndiciatorPos))  
            }
        }
        else
        {
            OldTextPos = Cursor
            TextPos = clamp(EGP:egpPos(250), vec2(-999999999,(-FileLines:count() * Fontsize) + 512), vec2(LineNumLen,0))    
            
            if(EGP:egpHasObject(252))
            {
                EGP:egpRemove(252)
            } 
        }

        EGP:egpPos(251, vec2(EGP:egpPos(250)[1],0))
        
        if(changed(!useDown()) & !useDown())
        {
            if(LineIndex != PrevLine)
            {
                CurrentSnippet = FileLines:getTextSnippet(LineIndex, ceil(LineIndex + 512 / Fontsize) - 2)
                reloadScript()   
            }
            
            PrevLine = LineIndex
        }   
        
        if(changed(useDown()) & useDown())
        {
            OldCursor = Cursor   
        }

        if(chat("goto"))
        {
            local Line = User:lastSaid():explode(" ")[2, string]
            
            if(Line:isNumber())
            {
                local I = clamp(Line:toNumber(), 1, FileLines:count())
                LineIndex = I                
                reloadView() 
            }
        }
        elseif(chat("size"))
        {
            local Size = User:lastSaid():explode(" ")[2, string]
            
            if(Size:isNumber())
            {
                Fontsize = Size:toNumber()          
                reloadView()
            }               
        }
        elseif(oChat("wl"))
        {
            local Name = owner():lastSaid():sub(5, owner():lastSaid():length())
            local Player = findPlayerByName(Name)
            if(Player != noentity())
            {
                if(!onWhitelist(Player:steamID()))
                {
                    whitelistUser(Player:steamID()) 
                    hint("\"" + Name + "\" has been whitelisted.", 2)         
                }
                else
                {
                    hint("\"" + Name + "\" is already whitelisted.", 2)          
                }       
            }
            else
            {
                hint("\"" + Name + "\" is not a player.", 2)   
            }
        }
        elseif(oChat("bl"))
        {
            local Name = owner():lastSaid():sub(5, owner():lastSaid():length())
            local Player = findPlayerByName(Name)
            if(Player != noentity())
            {
                if(onWhitelist(Player:steamID()))
                {
                    blacklistUser(Player:steamID())  
                    hint("\"" + Name + "\" has been blacklisted.", 2)      
                }
                else
                {
                    hint("\"" + Name + "\" is already blacklisted.", 2)          
                }       
            }
            else
            {
                hint("\"" + Name + "\" is not a player.", 2)   
            }            
        }
    }
    
    if(changed(Evaluated) & Evaluated)
    {
        reloadView()
        hideConsole()
        hideLoading()
        CurProgress = 0
        hint("Evaluation completed", 2)        
    } 

    if(clk("update") & Evaluated)
    {
        local Distances = table()
        local C = 1
        foreach(I, Ply:entity = players())
        {
            if(onWhitelist(Ply:steamID()) | Ply == owner())
            {
                Distances[C, table] = table("ent" = Ply, "distance" = EGP:entity():boxCenterW():distance(Ply:pos()))
                C++
            }   
        }

        if(Distances:count() > 1)
        {
            Distances = Distances:bubbleSort()
            User = Distances[Distances:count(), table]["ent", entity]
        }        
        else
        {
            User = Distances[1, table]["ent", entity]  
        }
        
        timer("update", 1500)   
        
       # User = owner()
    }
    else
    {
        timer("update", 1500)   
    }    

    Cursor = EGP:egpCursor(User)
}
elseif(fileStatus() == _FILE_404)
{
    hint("This file does not exist.", 2)   
    hideLoading()
}

if(oChat("open"))
{
    local Name = owner():lastSaid():explode(" ")[2, string]:replace(" ", "_")      
    local NewPath = ">e2shared/" + Name + ".txt"
    resetAll()
    FileData:clear()
    CurrentSnippet = ""
    FileContent = ""
    ReadyToEvaluate = 0
    Evaluated = 0
    LineIndex = 1
    CurProgress = 0
    FileLines = array()
    OldTextPos = vec2()
    TextPos = vec2()
    SnippetCopy = CurrentSnippet
    DisplaySteps = -1
    DisplayingProg = 0
    Stepper = 0      
    loadFile(NewPath)
    initEGP()
    showLoading()
    hint("Reloading...", 2)
}
